pipeline {
    agent any
    
    environment {
        // È°πÁõÆÈÖçÁΩÆ
        PROJECT_NAME = 'iam-contracts'
        GO_VERSION = '1.24'
        DEFAULT_IMAGE_NAMESPACE = 'iam-contracts'
        DEFAULT_IMAGE_TAG = 'prod'
        
        // ÊûÑÂª∫‰∫ßÁâ©Ë∑ØÂæÑ
        BINARY_NAME = 'apiserver'
        BUILD_DIR = 'bin'
        
        // ÈÉ®ÁΩ≤ÈÖçÁΩÆ
        DEPLOY_USER = 'deploy'
        DEPLOY_HOST = '${DEPLOY_HOST}' // ‰ªé Jenkins Âá≠ÊçÆ‰∏≠Ëé∑Âèñ
        DEPLOY_PATH = '/opt/iam'
        
        // ÊúçÂä°ÈÖçÁΩÆ
        CONFIG_FILE = 'configs/apiserver.yaml'
        SERVICE_NAME = 'iam-apiserver'
        SERVICE_PORT = '8080'
        
        // Docker ÁΩëÁªú
        DOCKER_NETWORK = 'iam-network'
        
        // Git ‰ø°ÊÅØ (Â∞ÜÂú® Setup Èò∂ÊÆµËÆæÁΩÆ)
        GIT_COMMIT_SHORT = ''
        BUILD_TIME = ''
    }
    
    options {
        skipDefaultCheckout(true)
        timestamps()
        timeout(time: 30, unit: 'MINUTES')
        disableConcurrentBuilds()
        buildDiscarder(logRotator(numToKeepStr: '10'))
    }
    
    // ËøêË°åÊó∂ÂèÇÊï∞ÔºåÂèØÂú® Jenkins UI ‰∏≠ÈÖçÁΩÆ
    parameters {
        choice(name: 'DEPLOY_MODE', choices: ['docker', 'binary', 'systemd'], description: 'ÈÉ®ÁΩ≤Ê®°ÂºèÔºödocker (Docker ÂÆπÂô®), binary (‰∫åËøõÂà∂Áõ¥Êé•ËøêË°å), systemd (Á≥ªÁªüÊúçÂä°)')
        string(name: 'IMAGE_REGISTRY', defaultValue: 'iam-contracts', description: 'Docker ÈïúÂÉè‰ªìÂ∫ìÂëΩÂêçÁ©∫Èó¥')
        string(name: 'IMAGE_TAG', defaultValue: 'prod', description: 'Docker ÈïúÂÉèÊ†áÁ≠æ')
        booleanParam(name: 'LOAD_ENV_FROM_CREDENTIALS', defaultValue: true, description: '‰ªé Jenkins Âá≠ÊçÆÂä†ËΩΩÁéØÂ¢ÉÂèòÈáèÈÖçÁΩÆÊñá‰ª∂')
        string(name: 'ENV_CREDENTIALS_ID', defaultValue: 'iam-contracts-prod-env', description: 'ÁéØÂ¢ÉÂèòÈáèÂá≠ÊçÆ ID')
        booleanParam(name: 'RUN_TESTS', defaultValue: true, description: 'ËøêË°åÂçïÂÖÉÊµãËØï')
        booleanParam(name: 'RUN_LINT', defaultValue: true, description: 'ËøêË°å‰ª£Á†ÅÊ£ÄÊü•')
        booleanParam(name: 'SKIP_BUILD', defaultValue: false, description: 'Ë∑≥ËøáÊûÑÂª∫Èò∂ÊÆµÔºàÁî®‰∫é‰ªÖÈÉ®ÁΩ≤Âú∫ÊôØÔºâ')
        booleanParam(name: 'DOCKER_NO_CACHE', defaultValue: false, description: 'Docker ÊûÑÂª∫Êó∂‰∏ç‰ΩøÁî®ÁºìÂ≠ò')
        booleanParam(name: 'SKIP_DB_INIT', defaultValue: true, description: 'Ë∑≥ËøáÊï∞ÊçÆÂ∫ìÂàùÂßãÂåñÔºàÂ∑≤ÊúâÁéØÂ¢ÉÊé®ËçêË∑≥ËøáÔºâ')
        booleanParam(name: 'SKIP_DB_MIGRATE', defaultValue: true, description: 'Ë∑≥ËøáÊï∞ÊçÆÂ∫ìËøÅÁßª')
        booleanParam(name: 'SKIP_DB_SEED', defaultValue: true, description: 'Ë∑≥ËøáÂä†ËΩΩÁßçÂ≠êÊï∞ÊçÆÔºà‰ªÖÈ¶ñÊ¨°ÈÉ®ÁΩ≤ÈúÄË¶ÅÔºâ')
        booleanParam(name: 'PUSH_IMAGES', defaultValue: false, description: 'Êé®ÈÄÅ Docker ÈïúÂÉèÂà∞‰ªìÂ∫ì')
        booleanParam(name: 'DEPLOY_AFTER_BUILD', defaultValue: true, description: 'ÊûÑÂª∫ÂêéËá™Âä®ÈÉ®ÁΩ≤')
        string(name: 'DEPLOY_COMPOSE_FILES', defaultValue: 'build/docker/docker-compose.yml', description: 'Docker Compose ÈÖçÁΩÆÊñá‰ª∂ÔºàÁ©∫Ê†ºÂàÜÈöîÔºâ')
        booleanParam(name: 'ENABLE_HEALTH_CHECK', defaultValue: true, description: 'ÈÉ®ÁΩ≤ÂêéÊâßË°åÂÅ•Â∫∑Ê£ÄÊü•')
        booleanParam(name: 'AUTO_ROLLBACK', defaultValue: true, description: 'ÂÅ•Â∫∑Ê£ÄÊü•Â§±Ë¥•Êó∂Ëá™Âä®ÂõûÊªö')
        booleanParam(name: 'PRUNE_IMAGES', defaultValue: false, description: 'Ê∏ÖÁêÜÊÇ¨Á©∫ÁöÑ Docker ÈïúÂÉè')
        string(name: 'DB_ROOT_CREDENTIALS_ID', defaultValue: 'mysql-root-password', description: 'MySQL root ÂØÜÁ†ÅÂá≠ÊçÆ ID')
        string(name: 'DEPLOY_SSH_CREDENTIALS_ID', defaultValue: 'deploy-ssh-key', description: 'SSH ÈÉ®ÁΩ≤Âá≠ÊçÆ ID')
    }
    
    stages {
        stage('Checkout') {
            steps {
                deleteDir()
                checkout scm
                script {
                    // Âú® checkout ÂêéËÆæÁΩÆ Git Áõ∏ÂÖ≥ÂèòÈáè
                    env.GIT_COMMIT = sh(returnStdout: true, script: 'git rev-parse HEAD').trim()
                    env.GIT_COMMIT_SHORT = sh(returnStdout: true, script: 'git rev-parse --short HEAD').trim()
                    env.GIT_BRANCH = sh(returnStdout: true, script: 'git rev-parse --abbrev-ref HEAD').trim()
                    env.BUILD_TIME = sh(returnStdout: true, script: 'date -u +"%Y-%m-%d_%H:%M:%S"').trim()
                    echo "================================================"
                    echo "  È°πÁõÆ: ${env.PROJECT_NAME}"
                    echo "  ÂàÜÊîØ: ${env.GIT_BRANCH}"
                    echo "  Êèê‰∫§: ${env.GIT_COMMIT_SHORT}"
                    echo "  ÊûÑÂª∫: #${env.BUILD_NUMBER}"
                    echo "  Êó∂Èó¥: ${env.BUILD_TIME}"
                    echo "  ÈÉ®ÁΩ≤Ê®°Âºè: ${params.DEPLOY_MODE}"
                    echo "================================================"
                }
            }
        }
        
        stage('Setup') {
            steps {
                script {
                    // ÂàùÂßãÂåñÁéØÂ¢ÉÂèòÈáèÂíåÈÖçÁΩÆ
                    initializeEnvironment()
                }
            }
        }
        
        stage('‰æùËµñÁÆ°ÁêÜ') {
            when {
                allOf {
                    expression { env.RUN_BUILD == 'true' }
                    expression { params.DEPLOY_MODE != 'docker' }
                }
            }
            steps {
                echo 'üì¶ ‰∏ãËΩΩ Go ‰æùËµñ...'
                sh '''
                    go env -w GO111MODULE=on
                    go env -w GOPROXY=https://goproxy.cn,direct
                    go mod download
                    go mod tidy
                    go mod verify
                '''
            }
        }
        
        stage('‰ª£Á†ÅÊ£ÄÊü•') {
            when {
                allOf {
                    expression { env.RUN_LINT == 'true' }
                    expression { params.DEPLOY_MODE != 'docker' }
                }
            }
            parallel {
                stage('‰ª£Á†ÅÊ†ºÂºèÂåñÊ£ÄÊü•') {
                    steps {
                        echo 'üîç Ê£ÄÊü•‰ª£Á†ÅÊ†ºÂºè...'
                        sh '''
                            if ! command -v gofmt &> /dev/null; then
                                echo "gofmt ‰∏çÂèØÁî®ÔºåË∑≥ËøáÊ†ºÂºèÊ£ÄÊü•"
                            else
                                UNFORMATTED=$(gofmt -l .)
                                if [ -n "$UNFORMATTED" ]; then
                                    echo "‰ª•‰∏ãÊñá‰ª∂ÈúÄË¶ÅÊ†ºÂºèÂåñ:"
                                    echo "$UNFORMATTED"
                                    echo "‚ö†Ô∏è Âª∫ËÆÆËøêË°å: make fmt"
                                fi
                            fi
                        '''
                    }
                }
                
                stage('‰ª£Á†ÅÈùôÊÄÅÂàÜÊûê') {
                    steps {
                        echo 'üîç ËøêË°åÈùôÊÄÅÂàÜÊûê...'
                        sh '''
                            if command -v golangci-lint &> /dev/null; then
                                golangci-lint run --timeout=5m || echo "‚ö†Ô∏è ÂèëÁé∞‰∏Ä‰∫õÈóÆÈ¢òÔºå‰ΩÜÁªßÁª≠ÊûÑÂª∫"
                            else
                                echo "golangci-lint Êú™ÂÆâË£ÖÔºåË∑≥ËøáÈùôÊÄÅÂàÜÊûê"
                                go vet ./... || echo "‚ö†Ô∏è go vet ÂèëÁé∞ÈóÆÈ¢ò"
                            fi
                        '''
                    }
                }
            }
        }
        
        stage('ÂçïÂÖÉÊµãËØï') {
            when {
                allOf {
                    expression { env.RUN_TESTS == 'true' }
                    expression { params.DEPLOY_MODE != 'docker' }
                }
            }
            steps {
                echo 'üß™ ËøêË°åÂçïÂÖÉÊµãËØï...'
                sh '''
                    mkdir -p coverage
                    go test -v -race -coverprofile=coverage/coverage.out -covermode=atomic ./... || {
                        echo "‚ö†Ô∏è ÊµãËØïÂ§±Ë¥•Ôºå‰ΩÜÁªßÁª≠ÊûÑÂª∫ÔºàÂèØÊ†πÊçÆÈúÄË¶ÅË∞ÉÊï¥Ôºâ"
                        exit 0
                    }
                    
                    if [ -f coverage/coverage.out ]; then
                        go tool cover -func=coverage/coverage.out | tail -1
                    fi
                '''
            }
        }
        
        stage('ÁºñËØëÊûÑÂª∫') {
            when {
                expression { env.RUN_BUILD == 'true' && env.DEPLOY_MODE != 'docker' }
            }
            steps {
                echo 'üî® ÁºñËØë Go Â∫îÁî®...'
                sh '''
                    # Á°Æ‰øùÊûÑÂª∫ÁõÆÂΩïÂ≠òÂú®
                    mkdir -p ${BUILD_DIR}
                    
                    # ÊûÑÂª∫Â∫îÁî®
                    VERSION=$(git describe --tags --always --dirty 2>/dev/null || echo "v0.0.0-dev")
                    
                    CGO_ENABLED=0 GOOS=linux GOARCH=amd64 go build \
                        -ldflags "-s -w \
                            -X main.Version=${VERSION} \
                            -X main.BuildTime=${env.BUILD_TIME} \
                            -X main.GitCommit=${env.GIT_COMMIT_SHORT}" \
                        -o ${BUILD_DIR}/${BINARY_NAME} \
                        ./cmd/apiserver/
                    
                    # È™åËØÅÊûÑÂª∫‰∫ßÁâ©
                    if [ ! -f "${BUILD_DIR}/${BINARY_NAME}" ]; then
                        echo "‚ùå ÊûÑÂª∫Â§±Ë¥•Ôºö‰∫åËøõÂà∂Êñá‰ª∂‰∏çÂ≠òÂú®"
                        exit 1
                    fi
                    
                    # ÊòæÁ§∫Êñá‰ª∂‰ø°ÊÅØ
                    ls -lh ${BUILD_DIR}/${BINARY_NAME}
                    file ${BUILD_DIR}/${BINARY_NAME}
                '''
            }
        }
        
        stage('ÊûÑÂª∫ Docker ÈïúÂÉè') {
            when {
                expression { env.RUN_DOCKER_BUILD == 'true' }
            }
            steps {
                echo 'üê≥ ÊûÑÂª∫ Docker ÈïúÂÉè...'
                script {
                    def buildArgs = [
                        "VERSION=${env.VERSION}",
                        "BUILD_TIME=${env.BUILD_TIME}",
                        "GIT_COMMIT=${env.GIT_COMMIT_SHORT}"
                    ]
                    def noCacheFlag = env.DOCKER_NO_CACHE == 'true' ? '--no-cache' : ''
                    
                    sh """
                        docker build ${noCacheFlag} \
                            --build-arg ${buildArgs.join(' --build-arg ')} \
                            -f build/docker/Dockerfile \
                            -t ${env.IMAGE_TAG_FULL} \
                            -t ${env.IMAGE_REGISTRY}:latest \
                            .
                        
                        echo "‚úÖ Docker ÈïúÂÉèÊûÑÂª∫ÂÆåÊàê"
                        docker images ${env.IMAGE_REGISTRY}
                    """
                }
            }
        }
        
        stage('ÂáÜÂ§á Docker ÁΩëÁªú') {
            when {
                expression { env.RUN_DOCKER_BUILD == 'true' || env.DEPLOY_MODE == 'docker' }
            }
            steps {
                echo 'üîó ÂáÜÂ§á Docker ÁΩëÁªú...'
                sh '''
                    if ! docker network ls | grep -q ${DOCKER_NETWORK}; then
                        docker network create ${DOCKER_NETWORK}
                        echo "‚úÖ ÂàõÂª∫ÁΩëÁªú: ${DOCKER_NETWORK}"
                    else
                        echo "‚ÑπÔ∏è  ÁΩëÁªúÂ∑≤Â≠òÂú®: ${DOCKER_NETWORK}"
                    fi
                '''
            }
        }
        
        stage('Êé®ÈÄÅÈïúÂÉè') {
            when {
                expression { env.PUSH_IMAGES_FLAG == 'true' }
            }
            steps {
                echo 'üì§ Êé®ÈÄÅ Docker ÈïúÂÉè...'
                sh """
                    docker tag ${env.IMAGE_TAG_FULL} ${env.IMAGE_REGISTRY}/${env.PROJECT_NAME}:${env.IMAGE_TAG}
                    docker push ${env.IMAGE_REGISTRY}/${env.PROJECT_NAME}:${env.IMAGE_TAG}
                    
                    if [ "${env.IMAGE_TAG}" != "latest" ]; then
                        docker tag ${env.IMAGE_TAG_FULL} ${env.IMAGE_REGISTRY}/${env.PROJECT_NAME}:latest
                        docker push ${env.IMAGE_REGISTRY}/${env.PROJECT_NAME}:latest
                    fi
                    
                    echo "‚úÖ ÈïúÂÉèÊé®ÈÄÅÂÆåÊàê"
                """
            }
        }
        
        stage('Êï∞ÊçÆÂ∫ìÂàùÂßãÂåñ') {
            when {
                expression { env.RUN_DB_INIT == 'true' }
            }
            steps {
                withCredentials([string(credentialsId: params.DB_ROOT_CREDENTIALS_ID, variable: 'DB_ROOT_PASSWORD')]) {
                    echo 'üóÑÔ∏è ÂàùÂßãÂåñÊï∞ÊçÆÂ∫ì...'
                    sh '''
                        chmod +x scripts/sql/init-db.sh
                        DB_PASSWORD=${DB_ROOT_PASSWORD} scripts/sql/init-db.sh --skip-confirm
                        echo "‚úÖ Êï∞ÊçÆÂ∫ìÂàùÂßãÂåñÂÆåÊàê"
                    '''
                }
            }
        }
        
        stage('Êï∞ÊçÆÂ∫ìËøÅÁßª') {
            when {
                expression { env.RUN_DB_MIGRATE == 'true' }
            }
            steps {
                echo 'üîÑ ÊâßË°åÊï∞ÊçÆÂ∫ìËøÅÁßª...'
                sh '''
                    if [ -f scripts/sql/migrate.sh ]; then
                        chmod +x scripts/sql/migrate.sh
                        scripts/sql/migrate.sh
                        echo "‚úÖ Êï∞ÊçÆÂ∫ìËøÅÁßªÂÆåÊàê"
                    else
                        echo "‚ö†Ô∏è ËøÅÁßªËÑöÊú¨‰∏çÂ≠òÂú®ÔºåË∑≥Ëøá"
                    fi
                '''
            }
        }
        
        stage('Âä†ËΩΩÁßçÂ≠êÊï∞ÊçÆ') {
            when {
                expression { env.RUN_DB_SEED == 'true' }
            }
            steps {
                echo 'üå± Âä†ËΩΩÁßçÂ≠êÊï∞ÊçÆ...'
                sh '''
                    chmod +x scripts/sql/init-db.sh
                    scripts/sql/init-db.sh --seed-only --skip-confirm
                    echo "‚úÖ ÁßçÂ≠êÊï∞ÊçÆÂä†ËΩΩÂÆåÊàê"
                '''
            }
        }
        
        stage('ÈÉ®ÁΩ≤') {
            when {
                expression { env.RUN_DEPLOY == 'true' }
            }
            steps {
                script {
                    if (env.DEPLOY_MODE == 'docker') {
                        deployWithDocker()
                    } else if (env.DEPLOY_MODE == 'systemd') {
                        deployWithSystemd()
                    } else {
                        deployBinary()
                    }
                }
            }
        }
        
        stage('ÂÅ•Â∫∑Ê£ÄÊü•') {
            when {
                expression { env.ENABLE_HEALTH_CHECK == 'true' && env.RUN_DEPLOY == 'true' }
            }
            steps {
                script {
                    echo 'üîç ÊâßË°åÂÅ•Â∫∑Ê£ÄÊü•...'
                    def healthCheckPassed = performHealthCheck()
                    
                    if (!healthCheckPassed && env.AUTO_ROLLBACK == 'true') {
                        echo '‚ùå ÂÅ•Â∫∑Ê£ÄÊü•Â§±Ë¥•ÔºåÊâßË°åËá™Âä®ÂõûÊªö...'
                        performRollback()
                        error('ÂÅ•Â∫∑Ê£ÄÊü•Â§±Ë¥•ÔºåÂ∑≤ÂõûÊªöÂà∞‰∏ä‰∏ÄÁâàÊú¨')
                    } else if (!healthCheckPassed) {
                        error('ÂÅ•Â∫∑Ê£ÄÊü•Â§±Ë¥•')
                    }
                }
            }
        }
        
        stage('Ê∏ÖÁêÜ') {
            when {
                expression { env.RUN_IMAGE_PRUNE == 'true' }
            }
            steps {
                echo 'üßπ Ê∏ÖÁêÜÊÇ¨Á©∫ÈïúÂÉè...'
                sh '''
                    docker image prune -f
                    echo "‚úÖ Ê∏ÖÁêÜÂÆåÊàê"
                '''
            }
        }
    }
    
    post {
        success {
            script {
                echo '‚úÖ ÈÉ®ÁΩ≤ÊàêÂäüÔºÅ'
                // ‰ΩøÁî® try-catch Èò≤Ê≠¢ÂèòÈáèÊú™ÂÆö‰πâÂØºËá¥ÈîôËØØ
                try {
                    echo """
                    ================================================
                    üéâ ÈÉ®ÁΩ≤ÊàêÂäü
                    ================================================
                    È°πÁõÆ: ${env.PROJECT_NAME ?: 'iam-contracts'}
                    ÂàÜÊîØ: ${env.GIT_BRANCH ?: 'unknown'}
                    Êèê‰∫§: ${env.GIT_COMMIT_SHORT ?: 'unknown'}
                    ÊûÑÂª∫: #${env.BUILD_NUMBER ?: '0'}
                    Êó∂Èó¥: ${env.BUILD_TIME ?: 'unknown'}
                    ÈÉ®ÁΩ≤Ê®°Âºè: ${env.DEPLOY_MODE ?: 'unknown'}
                    ================================================
                    """
                } catch (Exception e) {
                    echo "ÈÉ®ÁΩ≤ÊàêÂäüÔºàÈÉ®ÂàÜ‰ø°ÊÅØËé∑ÂèñÂ§±Ë¥•Ôºâ"
                }
            }
        }
        
        failure {
            script {
                echo '‚ùå ÈÉ®ÁΩ≤Â§±Ë¥•ÔºÅ'
                // ‰ΩøÁî® try-catch Èò≤Ê≠¢ÂèòÈáèÊú™ÂÆö‰πâÂØºËá¥ÈîôËØØ
                try {
                    echo """
                    ================================================
                    ‚ö†Ô∏è ÈÉ®ÁΩ≤Â§±Ë¥•
                    ================================================
                    È°πÁõÆ: ${env.PROJECT_NAME ?: 'iam-contracts'}
                    ÂàÜÊîØ: ${env.GIT_BRANCH ?: 'unknown'}
                    ÊûÑÂª∫: #${env.BUILD_NUMBER ?: '0'}
                    ================================================
                    ËØ∑Ê£ÄÊü•ÊûÑÂª∫Êó•Âøó
                    """
                } catch (Exception e) {
                    echo "ÈÉ®ÁΩ≤Â§±Ë¥•ÔºàËØ¶ÁªÜ‰ø°ÊÅØËé∑ÂèñÂ§±Ë¥•Ôºâ"
                }
            }
        }
        
        always {
            script {
                // ‰ΩøÁî® try-catch Èò≤Ê≠¢Âú® node Â§ñÊâßË°å sh ÂëΩ‰ª§
                try {
                    echo 'üßπ Ê∏ÖÁêÜÂ∑•‰ΩúÁ©∫Èó¥...'
                    sh '''
                        rm -rf deploy coverage
                    '''
                } catch (Exception e) {
                    echo "Ê∏ÖÁêÜË∑≥ËøáÔºàÂ∑•‰ΩúÁ©∫Èó¥‰∏çÂèØÁî®Ôºâ: ${e.message}"
                }
            }
        }
    }
}

// ============================================================================
// ËæÖÂä©ÂáΩÊï∞
// ============================================================================

def initializeEnvironment() {
    // ‰ªéÂá≠ÊçÆÂä†ËΩΩÁéØÂ¢ÉÂèòÈáè
    if (flagEnabled(params.LOAD_ENV_FROM_CREDENTIALS) && params.ENV_CREDENTIALS_ID?.trim()) {
        loadEnvFromCredentials(params.ENV_CREDENTIALS_ID.trim())
    } else {
        echo '‚ÑπÔ∏è  Ë∑≥Ëøá‰ªéÂá≠ÊçÆÂä†ËΩΩÁéØÂ¢ÉÂèòÈáè'
    }
    
    // ËÆæÁΩÆÈÉ®ÁΩ≤Ê®°Âºè
    env.DEPLOY_MODE = params.DEPLOY_MODE?.trim() ?: 'binary'
    
    // ËÆæÁΩÆÈïúÂÉèÈÖçÁΩÆ
    env.IMAGE_REGISTRY = normalizeRegistry(params.IMAGE_REGISTRY) ?: env.DEFAULT_IMAGE_NAMESPACE
    env.IMAGE_TAG = params.IMAGE_TAG?.trim() ?: env.DEFAULT_IMAGE_TAG
    env.IMAGE_TAG_FULL = buildImageTag(env.IMAGE_REGISTRY, env.PROJECT_NAME, env.IMAGE_TAG)
    
    // ËÆæÁΩÆÁâàÊú¨‰ø°ÊÅØ
    env.VERSION = sh(returnStdout: true, script: 'git describe --tags --always --dirty 2>/dev/null || echo "v0.0.0-dev"').trim()
    
    // ËÆæÁΩÆËøêË°åÊ†áÂøó
    env.RUN_BUILD = shouldSkip(params.SKIP_BUILD, env.SKIP_BUILD) ? 'false' : 'true'
    env.RUN_TESTS = flagEnabled(params.RUN_TESTS) ? 'true' : 'false'
    env.RUN_LINT = flagEnabled(params.RUN_LINT) ? 'true' : 'false'
    
    // Docker Áõ∏ÂÖ≥
    env.RUN_DOCKER_BUILD = (env.DEPLOY_MODE == 'docker' && env.RUN_BUILD == 'true') ? 'true' : 'false'
    env.DOCKER_NO_CACHE = flagEnabled(params.DOCKER_NO_CACHE) ? 'true' : 'false'
    
    // Êï∞ÊçÆÂ∫ìÊìç‰ΩúÊ†áÂøó
    env.RUN_DB_INIT = params.SKIP_DB_INIT ? 'false' : 'true'
    env.RUN_DB_MIGRATE = params.SKIP_DB_MIGRATE ? 'false' : 'true'
    env.RUN_DB_SEED = params.SKIP_DB_SEED ? 'false' : 'true'
    
    // Êé®ÈÄÅÂíåÈÉ®ÁΩ≤Ê†áÂøó
    def pushImages = flagEnabled(params.PUSH_IMAGES) || flagEnabled(env.PUSH_IMAGES)
    env.PUSH_IMAGES_FLAG = pushImages ? 'true' : 'false'
    
    def deployAfterBuild = flagEnabled(params.DEPLOY_AFTER_BUILD) || flagEnabled(env.DEPLOY_AFTER_BUILD)
    env.RUN_DEPLOY = (deployAfterBuild && !flagEnabled(env.SKIP_DEPLOY)) ? 'true' : 'false'
    
    // ÂÖ∂‰ªñÈÖçÁΩÆ
    env.DEPLOY_COMPOSE_FILES = params.DEPLOY_COMPOSE_FILES?.trim() ?: 'build/docker/docker-compose.yml'
    env.ENABLE_HEALTH_CHECK = flagEnabled(params.ENABLE_HEALTH_CHECK) ? 'true' : 'false'
    env.AUTO_ROLLBACK = flagEnabled(params.AUTO_ROLLBACK) ? 'true' : 'false'
    
    def pruneImages = flagEnabled(params.PRUNE_IMAGES) || flagEnabled(env.PRUNE_IMAGES)
    env.RUN_IMAGE_PRUNE = pruneImages ? 'true' : 'false'
    
    // ÊâìÂç∞ÈÖçÁΩÆ‰ø°ÊÅØ
    echo """
    ================================================
    ÁéØÂ¢ÉÈÖçÁΩÆ
    ================================================
    ÈÉ®ÁΩ≤Ê®°Âºè: ${env.DEPLOY_MODE}
    ÈïúÂÉè‰ªìÂ∫ì: ${env.IMAGE_REGISTRY}
    ÈïúÂÉèÊ†áÁ≠æ: ${env.IMAGE_TAG}
    ÂÆåÊï¥ÈïúÂÉè: ${env.IMAGE_TAG_FULL}
    ÁâàÊú¨Âè∑: ${env.VERSION}
    ËøêË°åÊûÑÂª∫: ${env.RUN_BUILD}
    ËøêË°åÊµãËØï: ${env.RUN_TESTS}
    ËøêË°åÊ£ÄÊü•: ${env.RUN_LINT}
    DockerÊûÑÂª∫: ${env.RUN_DOCKER_BUILD}
    DockerÊó†ÁºìÂ≠ò: ${env.DOCKER_NO_CACHE}
    Êï∞ÊçÆÂ∫ìÂàùÂßãÂåñ: ${env.RUN_DB_INIT}
    Êï∞ÊçÆÂ∫ìËøÅÁßª: ${env.RUN_DB_MIGRATE}
    Âä†ËΩΩÁßçÂ≠êÊï∞ÊçÆ: ${env.RUN_DB_SEED}
    Êé®ÈÄÅÈïúÂÉè: ${env.PUSH_IMAGES_FLAG}
    ÊâßË°åÈÉ®ÁΩ≤: ${env.RUN_DEPLOY}
    ÂÅ•Â∫∑Ê£ÄÊü•: ${env.ENABLE_HEALTH_CHECK}
    Ëá™Âä®ÂõûÊªö: ${env.AUTO_ROLLBACK}
    Ê∏ÖÁêÜÈïúÂÉè: ${env.RUN_IMAGE_PRUNE}
    ================================================
    """
}

def loadEnvFromCredentials(String credentialsId) {
    withCredentials([file(credentialsId: credentialsId, variable: 'ENV_FILE')]) {
        def content = readFile(ENV_FILE)
        def target = "${env.WORKSPACE}/.pipeline.env"
        writeFile file: target, text: content
        env.PIPELINE_ENV_FILE = target
        
        def exposedKeys = content.split('\n')
            .findAll { line ->
                def trimmed = line.trim()
                trimmed && !trimmed.startsWith('#') && trimmed.contains('=')
            }
            .collect { entry ->
                entry.split('=', 2)[0].replaceFirst(/^export\s+/, '').trim()
            }
        
        echo "‚úÖ ‰ªéÂá≠ÊçÆ '${credentialsId}' Âä†ËΩΩÁéØÂ¢ÉÂèòÈáè (keys: ${exposedKeys.join(', ')})"
    }
}

def deployWithDocker() {
    echo 'üê≥ ‰ΩøÁî® Docker Compose ÈÉ®ÁΩ≤...'
    
    def composeFiles = env.DEPLOY_COMPOSE_FILES.split()
    def composeFileArgs = composeFiles.collect { "-f ${it}" }.join(' ')
    
    sh """
        # Â¶ÇÊûúÈúÄË¶ÅÊãâÂèñÈïúÂÉè
        if [ "${env.PUSH_IMAGES_FLAG}" = "true" ]; then
            docker-compose ${composeFileArgs} pull
        fi
        
        # ÂÅúÊ≠¢ÊóßÂÆπÂô®
        docker-compose ${composeFileArgs} down
        
        # ÂêØÂä®Êñ∞ÂÆπÂô®
        docker-compose ${composeFileArgs} up -d
        
        # ÊòæÁ§∫Áä∂ÊÄÅ
        docker-compose ${composeFileArgs} ps
        
        echo "‚úÖ Docker ÈÉ®ÁΩ≤ÂÆåÊàê"
    """
}

def deployWithSystemd() {
    echo '‚öôÔ∏è ‰ΩøÁî® Systemd ÊúçÂä°ÈÉ®ÁΩ≤...'
    
    sshagent(credentials: [params.DEPLOY_SSH_CREDENTIALS_ID]) {
        sh """
            # ÂàõÂª∫ËøúÁ®ãÁõÆÂΩï
            ssh -o StrictHostKeyChecking=no ${env.DEPLOY_USER}@${env.DEPLOY_HOST} "
                mkdir -p ${env.DEPLOY_PATH}/{bin,configs,logs,scripts}
                mkdir -p /var/log/iam-contracts
            "
            
            # ‰∏ä‰º†Êñá‰ª∂
            echo "üì§ ‰∏ä‰º†ÈÉ®ÁΩ≤Êñá‰ª∂..."
            scp -o StrictHostKeyChecking=no ${BUILD_DIR}/${BINARY_NAME} ${env.DEPLOY_USER}@${env.DEPLOY_HOST}:${env.DEPLOY_PATH}/bin/
            scp -o StrictHostKeyChecking=no -r configs ${env.DEPLOY_USER}@${env.DEPLOY_HOST}:${env.DEPLOY_PATH}/
            scp -o StrictHostKeyChecking=no build/systemd/iam-apiserver.service ${env.DEPLOY_USER}@${env.DEPLOY_HOST}:/tmp/
            
            # ÈÉ®ÁΩ≤ÊúçÂä°
            ssh -o StrictHostKeyChecking=no ${env.DEPLOY_USER}@${env.DEPLOY_HOST} "
                # ÂÆâË£Ö systemd ÊúçÂä°
                if [ ! -f /etc/systemd/system/${env.SERVICE_NAME}.service ]; then
                    sudo mv /tmp/iam-apiserver.service /etc/systemd/system/
                    sudo systemctl daemon-reload
                    sudo systemctl enable ${env.SERVICE_NAME}
                fi
                
                # ÈáçÂêØÊúçÂä°
                sudo systemctl restart ${env.SERVICE_NAME}
                sleep 3
                
                # Ê£ÄÊü•Áä∂ÊÄÅ
                sudo systemctl status ${env.SERVICE_NAME} --no-pager
            "
            
            echo "‚úÖ Systemd ÊúçÂä°ÈÉ®ÁΩ≤ÂÆåÊàê"
        """
    }
}

def deployBinary() {
    echo 'üì¶ ‰ΩøÁî®‰∫åËøõÂà∂Êñá‰ª∂ÈÉ®ÁΩ≤...'
    
    sshagent(credentials: [params.DEPLOY_SSH_CREDENTIALS_ID]) {
        sh """
            # ÂàõÂª∫ËøúÁ®ãÁõÆÂΩï
            ssh -o StrictHostKeyChecking=no ${env.DEPLOY_USER}@${env.DEPLOY_HOST} "
                mkdir -p ${env.DEPLOY_PATH}/{bin,configs,logs,scripts}
            "
            
            # ‰∏ä‰º†Êñá‰ª∂
            echo "üì§ ‰∏ä‰º†ÈÉ®ÁΩ≤Êñá‰ª∂..."
            scp -o StrictHostKeyChecking=no ${BUILD_DIR}/${BINARY_NAME} ${env.DEPLOY_USER}@${env.DEPLOY_HOST}:${env.DEPLOY_PATH}/bin/
            scp -o StrictHostKeyChecking=no -r configs ${env.DEPLOY_USER}@${env.DEPLOY_HOST}:${env.DEPLOY_PATH}/
            scp -o StrictHostKeyChecking=no scripts/deploy.sh ${env.DEPLOY_USER}@${env.DEPLOY_HOST}:${env.DEPLOY_PATH}/scripts/
            
            # ÈÉ®ÁΩ≤ÊúçÂä°
            ssh -o StrictHostKeyChecking=no ${env.DEPLOY_USER}@${env.DEPLOY_HOST} "
                cd ${env.DEPLOY_PATH}
                chmod +x scripts/deploy.sh bin/${BINARY_NAME}
                
                # ‰ΩøÁî®ÈÉ®ÁΩ≤ËÑöÊú¨
                ./scripts/deploy.sh deploy
            "
            
            echo "‚úÖ ‰∫åËøõÂà∂ÈÉ®ÁΩ≤ÂÆåÊàê"
        """
    }
}

def performHealthCheck() {
    echo 'üîç ÊâßË°åÂÅ•Â∫∑Ê£ÄÊü•...'
    
    def maxRetry = 10
    def retryCount = 0
    def healthUrl = "http://${env.DEPLOY_HOST}:${env.SERVICE_PORT}/healthz"
    
    if (env.DEPLOY_MODE == 'docker') {
        healthUrl = "http://localhost:${env.SERVICE_PORT}/healthz"
    }
    
    while (retryCount < maxRetry) {
        try {
            def response = sh(
                script: "curl -sf ${healthUrl}",
                returnStatus: true
            )
            
            if (response == 0) {
                echo "‚úÖ ÂÅ•Â∫∑Ê£ÄÊü•ÈÄöËøá"
                return true
            }
        } catch (Exception e) {
            echo "ÂÅ•Â∫∑Ê£ÄÊü•Â§±Ë¥•: ${e.message}"
        }
        
        echo "Á≠âÂæÖÊúçÂä°Â∞±Áª™... (${retryCount + 1}/${maxRetry})"
        sleep 3
        retryCount++
    }
    
    echo "‚ùå ÂÅ•Â∫∑Ê£ÄÊü•Â§±Ë¥•"
    return false
}

def performRollback() {
    echo '‚è™ ÊâßË°åÂõûÊªö...'
    
    if (env.DEPLOY_MODE == 'docker') {
        sh '''
            echo "ÂõûÊªö Docker ÂÆπÂô®Âà∞‰∏ä‰∏ÄÁâàÊú¨..."
            # ËøôÈáåÂèØ‰ª•ÂÆûÁé∞ÂÖ∑‰ΩìÁöÑÂõûÊªöÈÄªËæë
            echo "‚ö†Ô∏è Docker ÂõûÊªöÈúÄË¶ÅÊâãÂä®ÂÆûÁé∞"
        '''
    } else {
        sshagent(credentials: [params.DEPLOY_SSH_CREDENTIALS_ID]) {
            sh """
                ssh -o StrictHostKeyChecking=no ${env.DEPLOY_USER}@${env.DEPLOY_HOST} "
                    cd ${env.DEPLOY_PATH}
                    if [ -f scripts/deploy.sh ]; then
                        ./scripts/deploy.sh rollback
                    else
                        echo '‚ö†Ô∏è ÂõûÊªöËÑöÊú¨‰∏çÂ≠òÂú®'
                    fi
                "
            """
        }
    }
}

boolean flagEnabled(def value) {
    if (value == null) {
        return false
    }
    def normalized = value.toString().trim().toLowerCase()
    return ['1', 'true', 'yes', 'y'].contains(normalized)
}

boolean shouldSkip(def paramValue, def envValue) {
    return flagEnabled(paramValue) || flagEnabled(envValue)
}

String normalizeRegistry(Object input) {
    def raw = input?.toString()?.trim()
    if (!raw) {
        return ''
    }
    return raw.endsWith('/') ? raw[0..-2] : raw
}

String buildImageTag(String registry, String component, String tag) {
    def base = registry?.trim()
    def repo = base ? "${base}/${component}" : component
    return "${repo}:${tag}"
}
