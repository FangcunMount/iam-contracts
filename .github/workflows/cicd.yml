name: CI/CD Pipeline

# ÂøÖÈúÄ/ÂèØÈÄâ Secrets ËØ¥ÊòéÔºö
# ÂøÖÈúÄÔºàÈÉ®ÁΩ≤ main ÂàÜÊîØÊó∂Âº∫Âà∂Ê†°È™åÔºâÔºö
#   SVRA_HOST, SVRA_USERNAME, SVRA_SSH_KEY
#   MYSQL_HOST, MYSQL_USERNAME, MYSQL_PASSWORD, MYSQL_DBNAME
#   REDIS_CACHE_HOST
#   IPD_ENCRYPTION_KEY
#   GRPC_CA_CHAIN, GRPC_SERVER_CRT, GRPC_SERVER_KEY
#   DOCKERHUB_USERNAME, DOCKERHUB_TOKEN
# ÂèØÈÄâÔºàÁº∫Â§±Êó∂‰ΩøÁî®ÈªòËÆ§ÊàñË∑≥ËøáÔºâÔºö
#   SVRA_SSH_PORT, SVRA_SUDO_PASSWORD
#   MYSQL_PORT
#   REDIS_CACHE_PORT, REDIS_CACHE_DB, REDIS_CACHE_USERNAME, REDIS_CACHE_PASSWORD
#   WWW_UID, WWW_GID
#   NSQ_LOOKUPD_HOST, NSQ_LOOKUPD_PORT, NSQ_NSQD_HOST, NSQ_NSQD_PORT (‰∫ã‰ª∂È©±Âä®Ê∂àÊÅØ)
# Ê≥®ÊÑèÔºöJWT Á≠æÂêç‰ΩøÁî® JWKS (RS256) ÈùûÂØπÁß∞ÂØÜÈí•ÔºåÂØÜÈí•Âú®ËøêË°åÊó∂Ëá™Âä®ÁîüÊàêÂπ∂ÊåÅ‰πÖÂåñÂà∞ /app/data/keys

on:
  push:
    branches: [ main, develop ]
  pull_request:
    branches: [ main ]
  workflow_dispatch:

env:
  GO_VERSION: '1.24'
  DOCKER_REGISTRY: ghcr.io
  IMAGE_NAME: fangcunmount/iam-contracts  # ÂøÖÈ°ªÂ∞èÂÜôÔºåDocker ‰∏çÊîØÊåÅÂ§ßÂÜôÂ≠óÊØç

jobs:
  validate-secrets:
    name: Validate Secrets
    runs-on: ubuntu-latest
    steps:
      - name: Check Required Secrets
        env:
          SVRA_HOST: ${{ secrets.SVRA_HOST }}
          SVRA_USERNAME: ${{ secrets.SVRA_USERNAME }}
          SVRA_SSH_KEY: ${{ secrets.SVRA_SSH_KEY }}
          SVRA_SSH_PORT: ${{ secrets.SVRA_SSH_PORT }}
          SVRA_SUDO_PASSWORD: ${{ secrets.SVRA_SUDO_PASSWORD }}
          MYSQL_HOST: ${{ secrets.MYSQL_HOST }}
          MYSQL_USERNAME: ${{ secrets.MYSQL_USERNAME }}
          MYSQL_PASSWORD: ${{ secrets.MYSQL_PASSWORD }}
          MYSQL_DBNAME: ${{ secrets.MYSQL_DBNAME }}
          MYSQL_PORT: ${{ secrets.MYSQL_PORT }}
          REDIS_CACHE_HOST: ${{ secrets.REDIS_CACHE_HOST }}
          REDIS_CACHE_PORT: ${{ secrets.REDIS_CACHE_PORT }}
          REDIS_CACHE_DB: ${{ secrets.REDIS_CACHE_DB }}
          REDIS_CACHE_USERNAME: ${{ secrets.REDIS_CACHE_USERNAME }}
          REDIS_CACHE_PASSWORD: ${{ secrets.REDIS_CACHE_PASSWORD }}
          IPD_ENCRYPTION_KEY: ${{ secrets.IPD_ENCRYPTION_KEY }}
          DOCKERHUB_USERNAME: ${{ secrets.DOCKERHUB_USERNAME }}
          DOCKERHUB_TOKEN: ${{ secrets.DOCKERHUB_TOKEN }}
          WWW_UID: ${{ secrets.WWW_UID }}
          WWW_GID: ${{ secrets.WWW_GID }}
          NSQ_LOOKUPD_HOST: ${{ secrets.NSQ_LOOKUPD_HOST }}
          NSQ_LOOKUPD_PORT: ${{ secrets.NSQ_LOOKUPD_PORT }}
          NSQ_NSQD_HOST: ${{ secrets.NSQ_NSQD_HOST }}
          NSQ_NSQD_PORT: ${{ secrets.NSQ_NSQD_PORT }}
        run: |
          echo "üîç Validating GitHub Action secrets..."
          VALIDATION_FAILED=0
          ENFORCE_REQUIRED=0
          if [ "${{ github.ref }}" == "refs/heads/main" ]; then
            ENFORCE_REQUIRED=1
            echo "üìã Checking required secrets for main branch deployment..."
          else
            echo "‚ÑπÔ∏è Not on main branch ‚Äì required secrets reported for awareness only."
          fi

          REQUIRED_SECRETS=(SVRA_HOST SVRA_USERNAME SVRA_SSH_KEY MYSQL_HOST MYSQL_USERNAME MYSQL_PASSWORD MYSQL_DBNAME REDIS_CACHE_HOST DOCKERHUB_USERNAME DOCKERHUB_TOKEN)
          OPTIONAL_SECRETS=(SVRA_SSH_PORT SVRA_SUDO_PASSWORD MYSQL_PORT REDIS_CACHE_PORT REDIS_CACHE_DB REDIS_CACHE_USERNAME REDIS_CACHE_PASSWORD WWW_UID WWW_GID NSQ_LOOKUPD_HOST NSQ_LOOKUPD_PORT NSQ_NSQD_HOST NSQ_NSQD_PORT)

          REQUIRED_SECRETS+=(IPD_ENCRYPTION_KEY)

          for SECRET_NAME in "${REQUIRED_SECRETS[@]}"; do
            VALUE=${!SECRET_NAME}
            if [ -n "$VALUE" ]; then
              echo "‚úÖ $SECRET_NAME is set"
            else
              if [ $ENFORCE_REQUIRED -eq 1 ]; then
                echo "‚ùå $SECRET_NAME is not set"
                VALIDATION_FAILED=1
              else
                echo "‚ö†Ô∏è $SECRET_NAME is not set (required when deploying main)"
              fi
            fi
          done

          echo ""
          echo "üìé Checking optional secrets (warnings only)..."
          for SECRET_NAME in "${OPTIONAL_SECRETS[@]}"; do
            VALUE=${!SECRET_NAME}
            if [ -n "$VALUE" ]; then
              echo "‚úÖ $SECRET_NAME is set"
            else
              case "$SECRET_NAME" in
                SVRA_SUDO_PASSWORD)
                  echo "‚ö†Ô∏è $SECRET_NAME is not set (needed only if sudo prompts for a password)"
                  ;;
                WWW_UID|WWW_GID)
                  echo "‚ö†Ô∏è $SECRET_NAME is not set (deploy job ÈªòËÆ§ 999/988)"
                  ;;
                MYSQL_PORT)
                  echo "‚ö†Ô∏è $SECRET_NAME is not set (defaults to 3306)"
                  ;;
                REDIS_CACHE_PORT)
                  echo "‚ö†Ô∏è $SECRET_NAME is not set (defaults to 6379)"
                  ;;
                REDIS_CACHE_DB)
                  echo "‚ö†Ô∏è $SECRET_NAME is not set (defaults to DB 0)"
                  ;;
                REDIS_CACHE_USERNAME)
                  echo "‚ö†Ô∏è $SECRET_NAME is not set (uses default Redis user)"
                  ;;
                REDIS_CACHE_PASSWORD)
                  echo "‚ö†Ô∏è $SECRET_NAME is not set (Redis cache auth disabled)"
                  ;;
                SVRA_SSH_PORT)
                  echo "‚ö†Ô∏è $SECRET_NAME is not set (defaults to 22)"
                  ;;
                *)
                  echo "‚ö†Ô∏è $SECRET_NAME is not set (optional)"
                  ;;
              esac
            fi
          done

          echo ""
          if [ $ENFORCE_REQUIRED -eq 1 ] && [ $VALIDATION_FAILED -eq 1 ]; then
            echo "‚ö†Ô∏è Secrets validation failed! Please configure the missing required secrets before pushing to main."
            echo "‚ÑπÔ∏è Continuing anyway for non-deployment jobs..."
          elif [ $ENFORCE_REQUIRED -eq 0 ] && [ $VALIDATION_FAILED -eq 1 ]; then
            echo "‚ö†Ô∏è Some required secrets are missing ‚Äì deployment on main will fail until they are set."
          else
            echo "‚úÖ Required secrets look good!"
          fi

  test:
    name: Run Tests
    needs: [validate-secrets, lint]
    if: always()
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4
      - name: Setup Go
        uses: actions/setup-go@v5
        with:
          go-version: ${{ env.GO_VERSION }}
          cache: true
      - name: Get dependencies
        run: |
          go mod download
          go mod verify
      - name: Run tests
        run: |
          go test -v -race -coverprofile=coverage.out -covermode=atomic ./...
      - name: Generate coverage report
        run: |
          go tool cover -func=coverage.out
      - name: Upload coverage
        uses: codecov/codecov-action@v3
        with:
          file: ./coverage.out
          flags: unittests
          name: codecov-umbrella

  lint:
    name: Lint Code
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4
      - name: Setup Go
        uses: actions/setup-go@v5
        with:
          go-version: ${{ env.GO_VERSION }}
          cache: true
      - name: Install dependencies
        run: |
          go mod download
      - name: Run make lint
        run: |
          make lint

  build:
    name: Build Application
    needs: [test, lint]
    runs-on: ubuntu-latest
    if: always()
    steps:
      - name: Checkout
        uses: actions/checkout@v4
      - name: Setup Go
        uses: actions/setup-go@v5
        with:
          go-version: ${{ env.GO_VERSION }}
          cache: true
      - name: Build
        run: |
          make build
      - name: Upload artifact
        uses: actions/upload-artifact@v4
        with:
          name: iam-apiserver
          path: bin/apiserver
          retention-days: 7

  docker:
    name: Build Docker Image
    needs: [build]
    runs-on: ubuntu-latest
    if: github.event_name == 'push' && github.ref == 'refs/heads/main'
    permissions:
      contents: read
      packages: write
    steps:
      - name: Checkout
        uses: actions/checkout@v4
      - name: Login to GitHub Container Registry
        uses: docker/login-action@v3
        with:
          registry: ${{ env.DOCKER_REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}
      - name: Login to Docker Hub
        uses: docker/login-action@v3
        with:
          username: ${{ secrets.DOCKERHUB_USERNAME }}
          password: ${{ secrets.DOCKERHUB_TOKEN }}
      - name: Build Docker image
        run: |
          make docker-build
        env:
          DOCKER_REGISTRY: ${{ env.DOCKER_REGISTRY }}
          DOCKER_REPOSITORY: fangcunmount
          VERSION: ${{ github.sha }}
          DOCKER_TAG: ${{ github.sha }}
      - name: Push to GitHub Container Registry
        run: |
          make docker-push
        env:
          DOCKER_REGISTRY: ${{ env.DOCKER_REGISTRY }}
          DOCKER_REPOSITORY: fangcunmount
          VERSION: ${{ github.sha }}
      - name: Tag and Push to Docker Hub
        run: |
          docker tag ghcr.io/fangcunmount/iam-contracts:${{ github.sha }} ${{ secrets.DOCKERHUB_USERNAME }}/iam-contracts:latest
          docker tag ghcr.io/fangcunmount/iam-contracts:${{ github.sha }} ${{ secrets.DOCKERHUB_USERNAME }}/iam-contracts:${{ github.sha }}
          docker push ${{ secrets.DOCKERHUB_USERNAME }}/iam-contracts:latest
          docker push ${{ secrets.DOCKERHUB_USERNAME }}/iam-contracts:${{ github.sha }}
          echo "‚úÖ ÈïúÂÉèÂ∑≤Êé®ÈÄÅÂà∞ Docker Hub:"
          echo "   - ${{ secrets.DOCKERHUB_USERNAME }}/iam-contracts:latest"
          echo "   - ${{ secrets.DOCKERHUB_USERNAME }}/iam-contracts:${{ github.sha }}"

  deploy:
    name: Deploy to Production
    needs: [build, docker]
    runs-on: ubuntu-latest
    if: github.event_name == 'push' && github.ref == 'refs/heads/main'
    environment:
      name: production
      url: https://iam.yangshujie.com
    env:
      WWW_UID: ${{ secrets.WWW_UID || '999' }}
      WWW_GID: ${{ secrets.WWW_GID || '988' }}
      IMAGE_TAG: ${{ github.sha }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Download artifact
        uses: actions/download-artifact@v4
        with:
          name: iam-apiserver
          path: ./artifacts

      # === Âú® Runner ‰æßÁîüÊàê .envÔºåÈÅøÂÖçËøúÁ´Ø heredoc + sudo ===
      - name: Prepare deployment files
        env:
          MYSQL_HOST: ${{ secrets.MYSQL_HOST }}
          MYSQL_PORT: ${{ secrets.MYSQL_PORT || 3306 }}
          MYSQL_USERNAME: ${{ secrets.MYSQL_USERNAME }}
          MYSQL_PASSWORD: ${{ secrets.MYSQL_PASSWORD }}
          MYSQL_DBNAME: ${{ secrets.MYSQL_DBNAME }}
          REDIS_CACHE_HOST: ${{ secrets.REDIS_CACHE_HOST }}
          REDIS_CACHE_PORT: ${{ secrets.REDIS_CACHE_PORT || 6379 }}
          REDIS_CACHE_DB: ${{ secrets.REDIS_CACHE_DB || 0 }}
          REDIS_CACHE_USERNAME: ${{ secrets.REDIS_CACHE_USERNAME }}
          REDIS_CACHE_PASSWORD: ${{ secrets.REDIS_CACHE_PASSWORD }}
          IPD_ENCRYPTION_KEY: ${{ secrets.IPD_ENCRYPTION_KEY }}
          NSQ_LOOKUPD_HOST: ${{ secrets.NSQ_LOOKUPD_HOST }}
          NSQ_LOOKUPD_PORT: ${{ secrets.NSQ_LOOKUPD_PORT || 4161 }}
          NSQ_NSQD_HOST: ${{ secrets.NSQ_NSQD_HOST }}
          NSQ_NSQD_PORT: ${{ secrets.NSQ_NSQD_PORT || 4150 }}
        run: |
          # artifact Êñá‰ª∂ÂêçÊòØ apiserverÔºåÈúÄË¶ÅÈáçÂëΩÂêç‰∏∫ iam-apiserver
          mv ./artifacts/apiserver ./artifacts/iam-apiserver
          chmod +x ./artifacts/iam-apiserver

          mkdir -p deploy-package/configs/env
          mkdir -p deploy-package/build/docker
          cp ./artifacts/iam-apiserver deploy-package/

          # Êã∑Ë¥ù‰ªìÂ∫ìÈÖçÁΩÆÂíåÁºñÊéíÊñá‰ª∂
          cp -r configs deploy-package/
          cp build/docker/docker-compose.prod.yml deploy-package/build/docker/docker-compose.prod.yml

          # ÁîüÊàêÁîü‰∫ßÁéØÂ¢É env(Êú¨Âú∞ÁîüÊàê,ÈöèÂåÖ‰∏ä‰º†)
          cat > deploy-package/configs/env/config.prod.env <<EOF
          # Auto-generated production environment configuration
          IAM_APISERVER_MYSQL_HOST=${MYSQL_HOST}:${MYSQL_PORT}
          IAM_APISERVER_MYSQL_USERNAME=${MYSQL_USERNAME}
          IAM_APISERVER_MYSQL_PASSWORD=${MYSQL_PASSWORD}
          IAM_APISERVER_MYSQL_DATABASE=${MYSQL_DBNAME}
          
          # Redis (ÁºìÂ≠ò/‰ª§Áâå)
          IAM_APISERVER_REDIS_CACHE_HOST=${REDIS_CACHE_HOST}
          IAM_APISERVER_REDIS_CACHE_PORT=${REDIS_CACHE_PORT}
          IAM_APISERVER_REDIS_CACHE_USERNAME=${REDIS_CACHE_USERNAME}
          IAM_APISERVER_REDIS_CACHE_PASSWORD=${REDIS_CACHE_PASSWORD}
          IAM_APISERVER_REDIS_CACHE_DATABASE=${REDIS_CACHE_DB}
          
          IAM_APISERVER_IDP_ENCRYPTION_KEY=${IPD_ENCRYPTION_KEY}
          
          # NSQ Configuration (Event-driven messaging)
          IAM_APISERVER_NSQ_ENABLED=${NSQ_LOOKUPD_HOST:+true}
          IAM_APISERVER_NSQ_LOOKUPD_ADDRS=${NSQ_LOOKUPD_HOST}:${NSQ_LOOKUPD_PORT}
          IAM_APISERVER_NSQ_NSQD_ADDR=${NSQ_NSQD_HOST}:${NSQ_NSQD_PORT}
          EOF

          echo "=========================================="
          echo "üìã Generated config.prod.env content:"
          echo "=========================================="
          cat deploy-package/configs/env/config.prod.env | sed 's/PASSWORD=.*/PASSWORD=***REDACTED***/g' | sed 's/ENCRYPTION_KEY=.*/ENCRYPTION_KEY=***REDACTED***/g'
          echo "=========================================="

          tar -czf deploy-package.tar.gz -C deploy-package .

      - name: Upload deployment package
        uses: appleboy/scp-action@v0.1.7
        with:
          host: ${{ secrets.SVRA_HOST }}
          username: ${{ secrets.SVRA_USERNAME }}
          key: ${{ secrets.SVRA_SSH_KEY }}
          port: ${{ secrets.SVRA_SSH_PORT || 22 }}
          source: "deploy-package.tar.gz"
          target: "/tmp"

      # === ËøúÁ´ØÂè™Áî®ÁôΩÂêçÂçïÂëΩ‰ª§ÔºõTLS Âõ∫ÂÆöÊåÇËΩΩÂà∞ /etc/iam-contracts/sslÔºà‰∏é apiserver.yaml ‰øùÊåÅ‰∏ÄËá¥Ôºâ
      - name: Deploy to Production Server
        uses: appleboy/ssh-action@v1.0.0
        env:
          DOCKER_REGISTRY: ${{ env.DOCKER_REGISTRY }}
          IMAGE_NAME: ${{ env.IMAGE_NAME }}
          IMAGE_TAG: ${{ env.IMAGE_TAG }}
          GHCR_USERNAME: ${{ github.actor }}
          GHCR_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          SUDO_PASSWORD: ${{ secrets.SVRA_SUDO_PASSWORD }}
          WWW_UID: ${{ env.WWW_UID }}
          WWW_GID: ${{ env.WWW_GID }}
        with:
          host: ${{ secrets.SVRA_HOST }}
          username: ${{ secrets.SVRA_USERNAME }}
          key: ${{ secrets.SVRA_SSH_KEY }}
          port: ${{ secrets.SVRA_SSH_PORT || 22 }}
          envs: DOCKER_REGISTRY,IMAGE_NAME,IMAGE_TAG,GHCR_USERNAME,GHCR_TOKEN,SUDO_PASSWORD,WWW_UID,WWW_GID
          script: |
            set -Eeuo pipefail

            APP_UID="${WWW_UID:-1000}"
            APP_GID="${WWW_GID:-1000}"

            # ----- SUDO Âä©ÊâãÔºöÂÖçÂØÜ‰ºòÂÖàÔºõËã•ÈúÄÂØÜÁ†ÅÂàôÊØèÊ¨° sudo ÈÉΩÂñÇÂØÜÁ†Å -----
            if sudo -n true 2>/dev/null; then
              SUDO="sudo"
              echo "‚ÑπÔ∏è Using passwordless sudo (NOPASSWD)."
            else
              if [ -z "${SUDO_PASSWORD:-}" ]; then
                echo "‚ùå sudo needs password. Provide SVRA_SUDO_PASSWORD or configure NOPASSWD." >&2
                exit 1
              fi
              sudo_pw() { sudo -S "$@" <<<"$SUDO_PASSWORD"; }
              export -f sudo_pw
              SUDO="sudo_pw"
              $SUDO -v || true
              echo "‚ÑπÔ∏è Using sudo with password via STDIN for every command."
            fi

            echo "=========================================="
            echo "Starting deployment to Production Server (SVRA)"
            echo "=========================================="

            # ÁõÆÂΩïÂáÜÂ§á
            $SUDO mkdir -p /opt/iam/configs/env /opt/iam/configs/ssl /var/log/iam-contracts /opt/iam/bin

            # Â§á‰ªΩ
            BACKUP_DIR="/opt/backups/iam/deployments"
            $SUDO mkdir -p "$BACKUP_DIR"
            TIMESTAMP=$(date +%Y%m%d_%H%M%S)
            if [ -d "/opt/iam/configs" ] && [ "$(ls -A /opt/iam/configs 2>/dev/null)" != "" ]; then
              $SUDO tar -czf "$BACKUP_DIR/backup_${TIMESTAMP}.tar.gz" \
                /opt/iam/configs /var/log/iam-contracts \
                2>/dev/null || echo "No previous version to backup"
            else
              echo "No previous version to backup"
            fi

            # Ëß£ÂåÖÂπ∂Áî® rsync ÂêåÊ≠•ÔºàÊõø‰ª£ cp -rÔºâ
            echo "Extracting new deployment package..."
            DEPLOY_TMP="/tmp/iam-deploy-$$"
            mkdir -p "$DEPLOY_TMP"
            tar -xzf /tmp/deploy-package.tar.gz -C "$DEPLOY_TMP"

            # ÁΩëÁªú
            if ! $SUDO docker network ls --format '{{.Name}}' | grep -w infra-network > /dev/null 2>&1; then
              echo "Creating Docker network infra-network (overlay attachable)..."
              $SUDO docker network create --driver overlay --attachable infra-network || {
                echo "‚ùå Failed to create overlay network. Ensure Docker Swarm is initialized."; exit 1; }
            fi

            # ======== Âõ∫ÂÆö‰ΩøÁî® /etc/iam-contracts/ssl ‰Ωú‰∏∫ÂÆπÂô®ÂÜÖËØÅ‰π¶ÁõÆÂΩï ========
            CERT_HOST_PATH="/data/ssl/certs/yangshujie.com.crt"
            KEY_HOST_PATH="/data/ssl/private/yangshujie.com.key"

            # Áî® root Ë∫´‰ªΩÊ£ÄÊü•ÔºåÈÅøÂÖç deploy Ë∫´‰ªΩË¢´ÊùÉÈôêÊå°‰Ωè
            if ! $SUDO test -r "$CERT_HOST_PATH"; then
              echo "‚ùå CERT not readable by root: $CERT_HOST_PATH"
              $SUDO ls -l "$CERT_HOST_PATH" || true
              exit 1
            fi

            if ! $SUDO test -r "$KEY_HOST_PATH"; then
              echo "‚ùå KEY not readable by root: $KEY_HOST_PATH"
              # ÊääÊØèÁ∫ßÁõÆÂΩïÊùÉÈôê‰πüÊâìÂç∞Âá∫Êù•‰æø‰∫éËØäÊñ≠
              $SUDO namei -l "$KEY_HOST_PATH" || true
              exit 1
            fi

            TLS_MOUNTS="-v $CERT_HOST_PATH:/etc/iam-contracts/ssl/yangshujie.com.crt:ro \
                        -v $KEY_HOST_PATH:/etc/iam-contracts/ssl/yangshujie.com.key:ro"
            # ===========================================================

            # GHCR ÁôªÂΩïÔºàÂ¶ÇÊúâ TokenÔºâ
            if [ -n "${GHCR_TOKEN:-}" ]; then
              echo "Logging into GitHub Container Registry..."
              echo "$GHCR_TOKEN" | $SUDO docker login "$DOCKER_REGISTRY" -u "$GHCR_USERNAME" --password-stdin >/dev/null || true
            fi

            # Á°Æ‰øù docker compose ÂèØÁî®
            if ! $SUDO docker compose version >/dev/null 2>&1; then
              echo "‚ùå docker compose is not available on target host."; exit 1;
            fi

            # Á°Æ‰øùÂü∫Á°ÄËÆæÊñΩÁΩëÁªúÂ≠òÂú®ÔºàÂ∑≤Áî±ËøêÁª¥È¢ÑÁΩÆÔºå‰ΩÜ‰ªçÊ†°È™åÔºâ
            if ! $SUDO docker network ls --format '{{.Name}}' | grep -w infra-network >/dev/null 2>&1; then
              echo "‚ùå Required network infra-network not found. Please create it first."; exit 1;
            fi

            # Â∞ÜÈÉ®ÁΩ≤ÂåÖÊîæÁΩÆÂà∞ /opt/iam
            $SUDO mkdir -p /opt/iam/build/docker
            $SUDO rsync -a "$DEPLOY_TMP/build/docker/docker-compose.prod.yml" /opt/iam/build/docker/docker-compose.prod.yml

            # Ë¶ÜÁõñÈÖçÁΩÆ‰∏é‰∫åËøõÂà∂
            $SUDO rsync -a "$DEPLOY_TMP/configs/" /opt/iam/configs/
            $SUDO rsync -a "$DEPLOY_TMP/iam-apiserver" /opt/iam/bin/iam-apiserver
            $SUDO chmod 0755 /opt/iam/bin/iam-apiserver
            $SUDO chown -R "$APP_UID:$APP_GID" /opt/iam/configs

            # ÂáÜÂ§áÊó•Âøó/ÂØÜÈí•ÁõÆÂΩï
            LOG_DIR_HOST="/data/logs/iam"
            $SUDO mkdir -p "$LOG_DIR_HOST"
            $SUDO chown -R "$APP_UID:$APP_GID" "$LOG_DIR_HOST"

            KEY_DIR_HOST="/data/ops/iam-keys"
            $SUDO mkdir -p "$KEY_DIR_HOST"
            $SUDO chown -R "$APP_UID:$APP_GID" "$KEY_DIR_HOST"
            $SUDO chmod 0750 "$KEY_DIR_HOST"

            # Ê£ÄÊü• gRPC mTLS ËØÅ‰π¶ÊòØÂê¶Â≠òÂú®ÔºàÁî± infra È°πÁõÆÁªü‰∏ÄÁÆ°ÁêÜÔºâ
            GRPC_DIR_HOST="/data/infra/ssl/grpc"
            GRPC_CA="$GRPC_DIR_HOST/ca/ca-chain.crt"
            GRPC_CRT="$GRPC_DIR_HOST/server/iam-apiserver.crt"
            GRPC_KEY="$GRPC_DIR_HOST/server/iam-apiserver.key"
            for f in "$GRPC_CA" "$GRPC_CRT" "$GRPC_KEY"; do
              if ! $SUDO test -r "$f"; then
                echo "‚ùå Missing or unreadable gRPC mTLS file: $f"
                exit 1
              fi
            done
            echo "‚úÖ gRPC certs found under $GRPC_DIR_HOST (permissions kept as-is; adjust manually if needed)"

            # ÂØºÂá∫ËøêË°åÊâÄÈúÄÁéØÂ¢ÉÂèòÈáèÔºà‰æõ compose ÂÜÖÊèíÂÄºÔºâ
            export DOCKER_REGISTRY IMAGE_NAME IMAGE_TAG
            export WWW_UID="$APP_UID" WWW_GID="$APP_GID"

            # ‰ΩøÁî® docker compose ÈÉ®ÁΩ≤Ôºà‰ªÖ iam-apiserver ÊúçÂä°ÔºåÂº∫Âà∂ÈáçÂª∫Âπ∂ÊãâÂèñÊúÄÊñ∞ÈïúÂÉèÔºâ
            COMPOSE_FILE="/opt/iam/build/docker/docker-compose.prod.yml"
            (cd /opt/iam && $SUDO docker compose -f "$COMPOSE_FILE" pull iam-apiserver)
            (cd /opt/iam && $SUDO docker compose -f "$COMPOSE_FILE" up -d --force-recreate --remove-orphans iam-apiserver)

            # Ê∏ÖÁêÜ‰∏¥Êó∂ÁõÆÂΩï‰∏é‰∏ä‰º†ÂåÖ
            rm -rf "$DEPLOY_TMP"
            rm -f /tmp/deploy-package.tar.gz

            # ÂÅ•Â∫∑Ê£ÄÊü•
            echo "Waiting for service to be ready..."
            ATTEMPTS=0
            MAX_ATTEMPTS=30
            while [ $ATTEMPTS -lt $MAX_ATTEMPTS ]; do
              if $SUDO docker exec iam-apiserver curl -sf http://127.0.0.1:9080/healthz > /dev/null 2>&1; then
                echo "‚úÖ API health check passed (attempt $ATTEMPTS)"
                $SUDO docker ps --filter "name=iam-apiserver" --format "table {{.Names}}\t{{.Status}}"
                break
              fi
              ATTEMPTS=$((ATTEMPTS + 1))
              if [ $ATTEMPTS -lt $MAX_ATTEMPTS ]; then
                echo "‚è≥ Health check attempt $ATTEMPTS/$MAX_ATTEMPTS failed, retrying in 5 seconds..."
                sleep 5
              fi
            done

            if [ $ATTEMPTS -ge $MAX_ATTEMPTS ]; then
              echo "‚ùå Service failed to start after $MAX_ATTEMPTS attempts"
              echo "Checking container status..."
              $SUDO docker ps -a --filter "name=iam-apiserver" || true
              echo "Checking container logs..."
              $SUDO docker logs --tail 2000 iam-apiserver || true
              exit 1
            fi

            # Ê∏ÖÁêÜÊóßÂ§á‰ªΩÔºà‰øùÁïô 10 ‰∏™Ôºâ
            echo "Cleaning up old backups..."
            $SUDO bash -c 'ls -t '"$BACKUP_DIR"'/backup_*.tar.gz 2>/dev/null | tail -n +11 | xargs -r rm -f 2>/dev/null || true'

            echo "=========================================="
            echo "‚úÖ Deployment completed successfully"
            echo "=========================================="

      - name: Verify Deployment
        uses: appleboy/ssh-action@v1.0.0
        env:
          SUDO_PASSWORD: ${{ secrets.SVRA_SUDO_PASSWORD }}
        with:
          host: ${{ secrets.SVRA_HOST }}
          username: ${{ secrets.SVRA_USERNAME }}
          key: ${{ secrets.SVRA_SSH_KEY }}
          port: ${{ secrets.SVRA_SSH_PORT || 22 }}
          envs: SUDO_PASSWORD
          script: |
            set -Eeuo pipefail

            if sudo -n true 2>/dev/null; then
              SUDO="sudo"
            else
              if [ -z "${SUDO_PASSWORD:-}" ]; then
                echo "‚ùå sudo needs password. Provide SVRA_SUDO_PASSWORD or configure NOPASSWD." >&2
                exit 1
              fi
              sudo_pw() { sudo -S "$@" <<<"$SUDO_PASSWORD"; }
              export -f sudo_pw
              SUDO="sudo_pw"
              $SUDO -v || true
            fi

            echo "Verifying deployment..."

            if $SUDO docker ps --filter "name=iam-apiserver" --format '{{.Names}}' | grep -w iam-apiserver > /dev/null 2>&1; then
              echo "‚úÖ Docker container is running"
            else
              echo "‚ùå Docker container is not running"
              $SUDO docker ps -a --filter "name=iam-apiserver" || true
              exit 1
            fi

            RESPONSE=$($SUDO docker exec iam-apiserver curl -s -o /dev/null -w "%{http_code}" http://127.0.0.1:9080/healthz || echo "000")
            if [ "$RESPONSE" = "200" ]; then
              echo "‚úÖ API is responding correctly"
            else
              echo "‚ùå API returned status: $RESPONSE"
              exit 1
            fi

            echo "Deployed version:"
            $SUDO docker exec iam-apiserver /app/apiserver version || echo "Version check skipped"

            echo "‚úÖ Deployment verification passed"

  notify:
    name: Send Notification
    needs: [deploy]
    runs-on: ubuntu-latest
    if: github.event_name == 'push' && github.ref == 'refs/heads/main'
    steps:
      - name: Log deployment status
        run: |
          if [ "${{ needs.deploy.result }}" == "success" ]; then
            echo "‚úÖ Deployment to production succeeded"
          else
            echo "‚ùå Deployment to production failed"
            exit 1
          fi
